using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Yass.SourceGeneration;

[Generator]
public class ContractGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;
        var binaryContractAttr = compilation.GetTypeByMetadataName("Yass.ContractAttribute");
        var binaryMemberAttr   = compilation.GetTypeByMetadataName("Yass.MemberAttribute");
        if (binaryContractAttr == null || binaryMemberAttr == null) return;

        foreach (var typeDecl in receiver.Candidates)
        {
            var model = compilation.GetSemanticModel(typeDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(typeDecl) is not INamedTypeSymbol typeSymbol) continue;
            if (!HasAttribute(typeSymbol, binaryContractAttr)) continue;

            var members = new List<(IPropertySymbol prop, int order)>();
            foreach (var member in typeSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var attr = member.GetAttributes()
                    .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, binaryMemberAttr));
                if (attr != null && attr.ConstructorArguments.Length >= 1 && attr.ConstructorArguments[0].Value is int order)
                    members.Add((member, order));
            }

            if (members.Count == 0) continue;
            members.Sort((a, b) => a.order.CompareTo(b.order));

            var source = GenerateTypeSerializer(typeSymbol, members);
            context.AddSource($"{typeSymbol.Name}.Yass.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static bool HasAttribute(INamedTypeSymbol symbol, INamedTypeSymbol attribute)
        => symbol.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attribute));

    private static string GenerateTypeSerializer(INamedTypeSymbol typeSymbol, List<(IPropertySymbol prop, int order)> members)
    {
        var ns = typeSymbol.ContainingNamespace is { IsGlobalNamespace: false } n
            ? n.ToDisplayString()
            : null;

        var typeKind = typeSymbol.IsRecord ? "record" : typeSymbol.TypeKind == TypeKind.Class ? "class" : "struct";
        var typeName = typeSymbol.Name;
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(ns)) { sb.AppendLine($"namespace {ns};"); sb.AppendLine(); }

        sb.AppendLine($"public partial {typeKind} {typeName} : IBinarySerializable<{typeName}>");
        sb.AppendLine("{");

        var sizeCompute = ComputeFixedSize(members);
        if (sizeCompute.isFixedSize)
        {
            sb.AppendLine($"    public const int Size = {sizeCompute.size};");
            sb.AppendLine();
        }

        // IBufferWriter<byte> serialize
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public static void Serialize(IBufferWriter<byte> writer, {typeName} value)");
        sb.AppendLine("    {");
        sb.AppendLine(sizeCompute.isFixedSize
            ? "        var span = writer.GetSpan(Size);"
            : "        var span = writer.GetSpan(256);");
        sb.AppendLine("        var pos = 0;");
        sb.AppendLine("        ref byte baseRef = ref MemoryMarshal.GetReference(span);");
        foreach (var (prop, _) in members)
            sb.AppendLine($"        {EmitWriteExpression(prop)}");
        sb.AppendLine(sizeCompute.isFixedSize
            ? "        writer.Advance(Size);"
            : "        writer.Advance(pos);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Span<byte> serialize (no allocations)
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public static void Serialize(Span<byte> span, {typeName} value)");
        sb.AppendLine("    {");
        sb.AppendLine("        var pos = 0;");
        sb.AppendLine("        ref byte baseRef = ref MemoryMarshal.GetReference(span);");
        foreach (var (prop, _) in members)
            sb.AppendLine($"        {EmitWriteExpression(prop)}");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ReadOnlySequence<byte> deserialize
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public static {typeName} Deserialize(ReadOnlySequence<byte> data)");
        sb.AppendLine("    {");
        sb.AppendLine("        var span = data.First.Span;");
        sb.AppendLine("        return Deserialize(span);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ReadOnlySpan<byte> deserialize
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public static {typeName} Deserialize(ReadOnlySpan<byte> span)");
        sb.AppendLine("    {");
        sb.AppendLine("        ref byte r = ref MemoryMarshal.GetReference(span);");
        var readTempNames = new List<string>();
        foreach (var (prop, _) in members)
        {
            var (readCode, varName) = EmitReadExpression(prop);
            sb.AppendLine($"        {readCode}");
            readTempNames.Add(varName);
        }
        sb.Append("        return new ").Append(typeName).Append("(");
        sb.Append(string.Join(", ", readTempNames));
        sb.AppendLine(");");
        sb.AppendLine("    }");

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static (bool isFixedSize, int size) ComputeFixedSize(List<(IPropertySymbol prop, int order)> members)
    {
        int total = 0;
        foreach (var (prop, _) in members)
        {
            var bytes = GetFixedSizeBytes(prop.Type);
            if (bytes < 0) return (false, 0);
            total += bytes;
        }
        return (true, total);
    }

    private static int GetFixedSizeBytes(ITypeSymbol t)
        => t.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) switch
        {
            "int" => 4,
            "long" => 8,
            "double" => 8,
            "float" => 4,
            "bool" => 1,
            "decimal" or "System.Decimal" => 16,
            "DateTime" or "System.DateTime" => 8,
            "Guid" or "System.Guid" => 16,
            _ => -1
        };

    private static string EmitWriteExpression(IPropertySymbol prop)
    {
        var name = prop.Name;
        var t = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        return t switch
        {
            "int" => $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), value.{name}); pos += 4;",
            "long" => $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), value.{name}); pos += 8;",
            "double" => $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), value.{name}); pos += 8;",
            "float" => $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), value.{name}); pos += 4;",
            "bool" => $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), (byte)(value.{name} ? 1 : 0)); pos += 1;",
            "decimal" or "System.Decimal" =>
                $"var bits_{name} = decimal.GetBits(value.{name}); " +
                $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), bits_{name}[0]); " +
                $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)(pos+4)), bits_{name}[1]); " +
                $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)(pos+8)), bits_{name}[2]); " +
                $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)(pos+12)), bits_{name}[3]); pos += 16;",
            "DateTime" or "System.DateTime" =>
                $"Unsafe.WriteUnaligned(ref Unsafe.AddByteOffset(ref baseRef, (IntPtr)pos), value.{name}.ToBinary()); pos += 8;",
            "Guid" or "System.Guid" =>
                $"var g_{name} = value.{name}; MemoryMarshal.Write(span.Slice(pos, 16), ref g_{name}); pos += 16;",
            _ => $"throw new NotSupportedException(\"Type {t} not supported for {name}\");"
        };
    }

    private static (string readCode, string varName) EmitReadExpression(IPropertySymbol prop)
    {
        var name = prop.Name;
        var t = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var varName = $"_{name}";
        return t switch
        {
            "int" => ($"int {varName} = Unsafe.ReadUnaligned<int>(ref r); r = ref Unsafe.AddByteOffset(ref r, (IntPtr)4);", varName),
            "long" => ($"long {varName} = Unsafe.ReadUnaligned<long>(ref r); r = ref Unsafe.AddByteOffset(ref r, (IntPtr)8);", varName),
            "double" => ($"double {varName} = Unsafe.ReadUnaligned<double>(ref r); r = ref Unsafe.AddByteOffset(ref r, (IntPtr)8);", varName),
            "float" => ($"float {varName} = Unsafe.ReadUnaligned<float>(ref r); r = ref Unsafe.AddByteOffset(ref r, (IntPtr)4);", varName),
            "bool" => ($"bool {varName} = Unsafe.ReadUnaligned<byte>(ref r) != 0; r = ref Unsafe.AddByteOffset(ref r, (IntPtr)1);", varName),
            "decimal" or "System.Decimal" =>
                ($"int d0_{name}=Unsafe.ReadUnaligned<int>(ref r); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)4);" +
                 $"int d1_{name}=Unsafe.ReadUnaligned<int>(ref r); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)4);" +
                 $"int d2_{name}=Unsafe.ReadUnaligned<int>(ref r); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)4);" +
                 $"int d3_{name}=Unsafe.ReadUnaligned<int>(ref r); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)4);" +
                 $"decimal {varName}=new decimal(new int[]{{d0_{name},d1_{name},d2_{name},d3_{name}}});", varName),
            "DateTime" or "System.DateTime" =>
                ($"long ticks_{name}=Unsafe.ReadUnaligned<long>(ref r); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)8); DateTime {varName}=DateTime.FromBinary(ticks_{name});", varName),
            "Guid" or "System.Guid" =>
                ($"Guid {varName}=MemoryMarshal.Read<Guid>(span.Slice((int)(Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref r)),16)); r=ref Unsafe.AddByteOffset(ref r,(IntPtr)16);", varName),
            _ => ($"throw new NotSupportedException(\"Type {t} not supported for {name}\");", varName)
        };
    }

    private sealed class SyntaxReceiver : ISyntaxReceiver
    {
        public List<TypeDeclarationSyntax> Candidates { get; } = new();
        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is TypeDeclarationSyntax tds && tds.AttributeLists.Count > 0)
                Candidates.Add(tds);
        }
    }
}